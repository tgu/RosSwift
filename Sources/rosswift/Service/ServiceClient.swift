//
//  ServiceClient.swift
//  RosSwift
//
//  Created by Thomas Gustafsson on 2018-10-24.
//

import Foundation
import NIO
import RosTime
import StdMsgs

enum ServiceError: Error {
    case invalidInput(String)
    case noResponse
}

internal final class ServiceClient {

    internal var implementation: Impl?

    private init() {}

    init(name: String, md5sum: String, persistent: Bool = false, headerValues: StringStringMap? = nil) {
        let impl = Impl(name: name, md5sum: md5sum, persistent: persistent, header: headerValues)
        implementation = impl
        if persistent {
            implementation?.serverLink = ServiceManager.instance.createServiceServerLink(
                    service: impl.name,
                    persistent: impl.persistent,
                    requestMd5sum: impl.serviceMd5sum,
                    responseMd5sum: impl.serviceMd5sum,
                    headerValues: impl.headerValue)
        }
    }

    func call<MReq: ServiceMessage, MRes: ServiceMessage>(req: MReq) -> EventLoopFuture<MRes?> {
        if MReq.srvMd5sum != MRes.srvMd5sum {
            fatalError("The request and response parameters to the service " +
                "call must be autogenerated from the same " +
                "server definition file (.srv). your service call " +
                "for \(implementation?.name ?? "no name") appeared to use request/response types " +
                "from different .srv files. (\(MReq.srvMd5sum) vs. \(MRes.srvMd5sum)")
        }
        let serializedRequest = SerializedMessage(msg: req)
        return call(req: serializedRequest, serviceMd5sum: MReq.srvMd5sum).map { ser -> MRes? in
            do {
                let res: MRes = try deserializeMessage(m: ser)
                return res
            } catch {
                ROS_ERROR("Exception thrown while while deserializing service call: \(error)")
                return nil
            }
        }
    }

   func call(req: SerializedMessage, serviceMd5sum: String) -> EventLoopFuture<SerializedMessage> {

        let eventLoop = threadGroup.next()
        let promise: EventLoopPromise<SerializedMessage> = eventLoop.newPromise()

        guard let impl = implementation, impl.serviceMd5sum == serviceMd5sum else {
            let err = ServiceError.invalidInput("Call to service [\(implementation!.name)]" +
                " with md5sum [\(serviceMd5sum)] does not match md5sum when the handle was" +
                " created ([\(implementation!.serviceMd5sum)])")
            promise.fail(error: err)
            return promise.futureResult
        }
        var link: ServiceServerLink?

        if impl.persistent {
            if impl.serverLink == nil {
                impl.serverLink = ServiceManager.instance.createServiceServerLink(
                    service: impl.name,
                    persistent: impl.persistent,
                    requestMd5sum: serviceMd5sum,
                    responseMd5sum: serviceMd5sum,
                    headerValues: impl.headerValue)

                if impl.serverLink == nil {
                    promise.fail(error: ServiceError.invalidInput("Could not create ServiceServerLink"))
                    return promise.futureResult
                }
            }
            link = impl.serverLink
        } else {
            link = ServiceManager.instance.createServiceServerLink(
                service: impl.name,
                persistent: impl.persistent,
                requestMd5sum: serviceMd5sum,
                responseMd5sum: serviceMd5sum,
                headerValues: impl.headerValue)
            if link == nil {
                promise.fail(error: ServiceError.invalidInput("Could not create ServiceServerLink"))
                return promise.futureResult
            }
        }
        promise.succeed(result: SerializedMessage())

        return link!.call(req: req)
    }

    func isValid() -> Bool {
        return implementation?.isValid() ?? false
    }

    func isPersistent() -> Bool {
        return implementation?.persistent ?? false
    }

    func shutdown() {
        implementation?.shutdown()
    }

    func waitForExistence(timeout: RosTime.Duration = RosTime.Duration(seconds: -1)) -> Bool {
        guard let impl = implementation else {
            return false
        }

        return Service.waitForService(serviceName: impl.name, timeout: timeout)
    }

    func exists() -> Bool {
        guard let impl = implementation else {
            return false
        }
        return Service.exists(serviceName: impl.name, printFailureReason: false)
    }

    func getService() -> String {
        return implementation?.name ?? ""
    }

}
